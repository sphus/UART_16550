
# UART设计与验证

# 项目概述

实现一个在ARM中通过APB总线连接的UART模块（Universal Asynchronous Receiver/Transmitter）模块，包括设计与验证两部分。

## 项目需求

> - 系统时钟最大工作频率满足100MHz，功能时钟满足26MHz
> - 具有系统和功能时钟域的复位功能
> - 数据传输满足通用串口时序，奇偶校验功能可配置
> - 波特率可任意配置,最高可配置为256000
> - 接收和发送FIFO复位单独可控，触发深度可配置
> - 数据收发中断功能可配置
> - 数据发送间隔可控
> - 具有状态指示功能
> - 具有FIFO数据量指示功能

## 设计

- **波特率产生模块**
    - 根据功能时钟和配置，产生收发波特率时钟。
- **数据接收**
    - 根据RX波特率时钟接收数据，进行奇偶校验，存放数据到RX FIFO，再由CUP经过APB总线读取数据。内含接收数据状态机。
- **数据发送**
    - CUP通过APB总线将需要发送的数据放到TX FIFO，根据TX波特率时钟进行数据发送。内含发送数据状态机。
- **寄存器配置**
    - 实现APB读写寄存器功能，中断操作，功能选择，模块状态指示等。

## 验证

- **波特率产生**
 	- 产生仿真环境使用的波特率时钟。
- **数据接收**
 	- 仿真环境的接收数据模型。
- **数据发送**
 	- 仿真环境的发送数据模型。
- **APB总线**
 	- 仿真环境的APB总线模型，模拟cpu响应中断和实现各种功能。
- **数据对比**
 	- 根据对比发送和接收的数据和时序，产生不同的对比结果，便于仿真时对结果的观察。
- **Testcase产生**
 	- 通过不同的激励或配置产生不同的case，验证时序和功能是否符合。

框架
-------------
 ![ref_frame](images\ref_frame.png)

# 跨时钟域的信号同步

## 两级同步

- 两级同步
    - 方法：跨时钟域的信号上加上两级或多级同步触发器

## 握手信号法
 ![Handshake](images\Handshake.webp)
使用握手信号xack和yreq，模块X将数据发送给模块Y。
下面是使用握手信号传输数据的例子。
1）模块X将数据放到数据总线上并发出xreq（请求）信号，表示有效数据已经放到数据总线上。
2）把xreq信号打两级同步到yclk时钟域。
3）模块Y在接收到xreq同步后的信号后，接收数据总线上的信号。
4）模块Y接收数据的同时发出yack（响应）信号，表示已经接收到了数据。
5）模块X接收到yack后打两级同步到xclk时钟域。
6）模块X在接收到yack同步后的信号后，使xreq无效，表示此次数据传输结束。
7）模块Y在发现xreq无效后，使yack无效。
8）模块X发现yack无效后可以进行下一笔数据传输。
优点：不论xclk和yclk的频率如何，都可以进行数据传输。
缺点：完成数据传输的延迟比使用异步FIFO传输大得多。


# FIFO设计

First In First Out，先入先出队列

## 同步FIFO
框图
![FIFO_sync_frame](images\FIFO_sync_frame.webp)
- FIFO深度
    - 深度设置为15
    - 数据宽度8bit
- 读写指针
    - rptr为读指针，指向下一个要读的地址
    - wptr为写指针，同样指向下一个要写的地址。
    - 有效的读写使能使读写指针递增。
- 空满信号产生
    - FIFO为空状态：rempty信号会拉起
    - 为了区分空满状态，将读写指针设置多1bit作为扩展位
        - 当FIFO为空时，读写指针完全相等；
        - 当FIFO为满时，读写指针最高位相反，低4位相等。
- FIFO数据状态指示
    - fifo_cnt，它的值为写指针与读指针的差值。表示FIFO中剩余的数据量

对应代码[UART_FIFO_sync.v](codes/UART_FIFO_sync.v)

## 异步FIFO

异步FIFO结构
![UART_FIFO_asyn](images\UART_FIFO_asyn.webp)

### 格雷码实现读写指针
格雷码从一个数变为下一个数时只有一位发生变化。

所以格雷码在转换时最多只会出现一位错误。比如从1000变为0000时，两级同步器采样要么为1000（旧值），要么为0000（新值），而不会出现其他的值。这样就可以避免产生错误的空满标志。

n位二进制转格雷码
$\begin{cases}
gray_{n-1} = bin_{n-1}\\
gray_{i} = bin_{i} \oplus bin_{i-1} , & i < n-1
\end{cases}$
对应代码
![gray_to_bin.v](codes\gray_to_bin.v)

n位格雷码转二进制
$\begin{cases}
bin_{n-1} = gray_{n-1}\\
bin_{i} = gray_{i} \oplus bin_{i+1} , & i < n-1\\
亦可bin_{i} = \oplus gray[n-1:i]
\end{cases}$
对应代码
![bin_to_gray.v](codes\bin_to_gray.v)

# 串口接收部分

- 实现
    - 配置信息同步
        - reg_if模块由APB总线配置寄存器产生
    - 接收状态机
    - 接收数据FIFO控制
        - 接收数据FIFO控制部分将接收完成的数据写入到FIFO，在CPU读取RX_FIFO寄存器时将FIFO数据读出送到RX_FIFO寄存器。
## 接收状态机
- IDLE
    - 状态机从IDLE状态开始，检测到uart_i的下降沿，进入START状态。
- START
    - START状态起始位是否为低（避免毛刺触发状态机），起始位正常即进入RX_DATA开始接收数据。
- RX_DATA
    - 接收满8bit后判断是否使能校验位，如使能，进入CHECK_DATA状态进行奇偶校验的判断；如不使能，直接进入停止状态STOP。
- CHECK_DATA
    - CHECK_DATA状态判断奇偶校验是否正确，不正确则发出p_error信号，在状态寄存器指示校验错误，待CPU处理返回p_error_ack后回到IDLE状态。如果正确，判断是否使能停止位检查；使能停止位检查则跳转到STOP状态；不使能则跳转到SEND状态。
- STOP
    - 同样的，在STOP状态检测停止位是否是高电平。如果是，表示停止位正确，跳转到SEND状态；如果不是，则发出st_error信号，在状态寄存器指示停止位错误，待CPU处理返回st_error_ack后回到IDLE状态。
- SEND
    - SEND状态主要是产生rx_start信号表示8bits数据接收正确，可以将数据写到接收FIFO。